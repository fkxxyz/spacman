# spacman #

## 简介 ##

archlinux 是个可高度定制的 linux 发行版，在使用的过程中，需要反复测试很多软件包的功能，以达到自己想要的效果，效果不好的卸载，用得好的留下，但由于依赖是复杂的树状结构，时间长了，容易忘记自己测试过哪些包，以至于有些包只是临时安装的后来忘了卸载，随着积累容易导致在系统里留下大量不必要的包。

pacman 的功能之一是可以查询安装原因，安装原因有两种“单独指定安装”和“作为其他软件包的依赖关系安装”，也可以通过 pacman -Qdt 找出所有没必要的依赖包，pacman -Qe 可以列出所有自己显式指定安装过的包，还可以通过 pacman -Rscn 卸载某个软件来将其不必要的依赖也同时卸载，但是依然没法满足以上需求，因为很多包都是自己指定安装，但是后来忘了自己只是临时测试这个包，测试过应当卸载，然而这类包显然留在系统中。

强迫症患者们当然希望自己的系统是干干净净，只有自己需要的包，没有其它任何垃圾包。

于是有了新的脚本需求。

## 需求实现 ##

需要这样一个脚本，这个脚本能实现：

1. 能够从一个文本文档里面读取软件列表（不包含“作为其他软件包的依赖关系安装”的包，只需要指定顶层包），根据此列表与系统已安装的包进行对比，进行依赖计算，列出所有多余的包，列出所有指定了却未安装的包。
2. 软件列表可以有以井号开头的注释，可以忽略空行，每行包含一个软件包。这样可以方便测试注释。
3. 设计命令行参数，在必要时可以指定不同的配置文件，也可以指定自己喜欢的包管理器命令如 yay ，让脚本自动调用包管理器来同步软件列表和系统。

有了这样一个脚本，以后测试就方便了，只需要编辑这个软件列表，在里面添加或删除软件的行，甚至可以井号注释临时的包，然后直接调用脚本同步，对系统里所有的包一目了然，轻而易举地掌控系统的所有包，而不会存在任何多余的包，实现随心所欲高度定制。

只要我不改变列表，那么我可以随意安装测试任何软件包，玩够了之后，直接执行 spacman -a 来回到列表的样子，此方法可以将一个列表看作是一个还原点，甚至可以设置多个还原点进行任意测试，大幅度提升定制效率！

本项目已经用 python3 实现，我将它取名为超级包管理器，脚本名称为 spacman ，已经打包上传到 aur，可以用 yay 直接安装：

```shell
yay -S spacman
```



## 用法 ##

```
用法: spacman [-h] [--config 列表文件] [--pacman 包管理器] [--apply] [--query]

可选参数:
  -h, --help            显示帮助信息
 --config 列表文件, -c 列表文件
                        指定列表文件（默认为 ~/.config/spacman.conf）
  --pacman 包管理器, -p 包管理器
                        指定包管理器（例如 yay，默认为 pacman）
  --apply, -a           自动调用包管理器，将列表应用到系统
  --query, -q           查询一个列表中所有的包
```

用法举例

```shell
# 将 ~/.config/spacman.conf 列表与系统已安装的包进行对比，输出结果
spacman

# 将 ~/spacman1.conf 作为列表进行对比，输出结果
spacman -c ~/spacman1.conf

# 将 ~/.config/spacman.conf 列表应用到系统
spacman -a
# 警告，万万不可将空列表应用到系统，否则会卸载所有软件包

# 将 ~/.config/spacman.conf 列表应用到系统，并用 yay 作为包管理器
spacman -a -p yay

# 列出 ~/.config/spacman.conf 列表中所有软件包并排序
spacman -q | sort
```

我的日常列表可参见 https://github.com/fkxxyz/archlinux-config/blob/master/spacman/spacman.conf

